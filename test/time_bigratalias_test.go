// Generated by: main
// TypeWriter: bigratalias
// Directive: +gen on *Time

package test

import (
	"math/big"
	"time"
)

// Le returns true if x is less than y
func (x *Time) Le(y *Time) bool {
	return x.rat.Cmp(y.rat) < 0
}

// Leq returns true if x is less than or equal to y
func (x *Time) Leq(y *Time) bool {
	return x.rat.Cmp(y.rat) <= 0
}

// Ge returns true if x is greater than y
func (x *Time) Ge(y *Time) bool {
	return x.rat.Cmp(y.rat) > 0
}

// Geq returns true if x is greater than or equal to y
func (x *Time) Geq(y *Time) bool {
	return x.rat.Cmp(y.rat) >= 0
}

// Eq returns true if x is equal to y
func (x *Time) Eq(y *Time) bool {
	return x.rat.Cmp(y.rat) == 0
}

// Neq returns true if x is not equal to y
func (x *Time) Neq(y *Time) bool {
	return x.rat.Cmp(y.rat) != 0
}

func (x *Time) Mul(y *Time) *Time {
	return NewTime(new(big.Rat).Mul(x.rat, y.rat))
}

func (x *Time) Neg() *Time {
	return NewTime(new(big.Rat).Neg(x.rat))
}

func Unix(t time.Time) *Time {
	return NewTime(big.NewRat(t.UnixNano(), 1e9))
}

func (x *Time) Add(y *Time) *Time {
	return NewTime(new(big.Rat).Add(x.rat, y.rat))
}

func (x *Time) Sub(y *Time) *Time {
	return NewTime(new(big.Rat).Sub(x.rat, y.rat))
}

func (x *Time) Div(y *Time) *Time {
	return x.Mul(y.Inv())
}

func (x *Time) AddInt64(y int64) *Time {
	return x.Add(NewTime(big.NewRat(y, 1)))
}

func (x *Time) SubInt64(y int64) *Time {
	return x.Sub(NewTime(big.NewRat(y, 1)))
}

func (x *Time) Max(y *Time) *Time {
	if x.Ge(y) {
		return x
	}
	return y
}

func (x *Time) Inv() *Time {
	return NewTime(new(big.Rat).Inv(x.rat))
}
